### Sinch: 26-06-2025
Q1.
employee(id, name, dept_id)
department(id, dept_name)
salary(id, amount, emp_id)

// Fetch depart_name and avg salary per department in the asecending order of avg salary

ANS :
SELECT
    d.dept_name,
    AVG(s.amount) AS avg_salary
FROM
    department d
    JOIN employee e ON d.id = e.dept_id
    JOIN salary s ON e.id = s.emp_id
    GROUP BY d.dept_name
    ORDER BY avg_salary ASC;


Q2.
REST vs SOAP

ANS :

| Feature             | REST (Representational State Transfer)               | SOAP (Simple Object Access Protocol)                               |
| ------------------- | ---------------------------------------------------- | ------------------------------------------------------------------ |
| Protocol        	  | Uses HTTP directly                                   | Can use HTTP, SMTP, etc., but follows strict XML messaging         |
| Data Format     	  | JSON, XML, HTML, or plain text                       | XML only                                                           |
| Flexibility     	  | More flexible and lightweight                        | Rigid and heavy due to strict standards                            |
| Ease of Use     	  | Easier to implement and use                          | More complex setup and structure                                   |
| Performance     	  | Faster, less bandwidth, better suited for web/mobile | Slower due to XML parsing and envelope overhead                    |
| Statefulness    	  | Stateless (default)                                  | Can be stateful or stateless                                       |
| Standards       	  | No official standards ‚Äì relies on conventions        | Strict standards ‚Äì WS-Security, WS-ReliableMessaging, etc.         |
| Error Handling  	  | Via HTTP status codes (e.g., 404, 500)               | Custom XML-based error codes                                       |
| Security        	  | Relies on HTTPS                                      | Built-in security features via WS-Security                         |
| Tooling/Support 	  | Widely supported in modern web APIs                  | Often used in enterprise or legacy systems                         |


When to Use:
REST: Best for web APIs, mobile apps, public APIs, and when you want speed and simplicity.

SOAP: Suitable for enterprise systems, financial services, and scenarios requiring strict security, transactions, or reliable messaging.

Q3. @Autowired vs @Qualifier


üîπ @Autowired
It is used for automatic dependency injection.

Spring will automatically inject a bean of the required type.

@Component
public class MyService {
    @Autowired
    private MyRepository myRepository; // Spring injects a matching bean
}
üëâ Problem:
If multiple beans of the same type exist, Spring doesn't know which one to inject, and you'll get a NoUniqueBeanDefinitionException.

üîπ @Qualifier
It is used along with @Autowired to specify exactly which bean should be injected when there are multiple candidates.

@Component
public class MyService {
    @Autowired
    @Qualifier("mongoRepository")
    private MyRepository myRepository;  // Injects the bean named "mongoRepository"
}

Example with multiple beans:
@Component("mongoRepository")
public class MongoRepository implements MyRepository {}

@Component("sqlRepository")
public class SqlRepository implements MyRepository {}
Now to inject a specific one:


@Autowired
@Qualifier("sqlRepository")
private MyRepository myRepository;

‚úÖ Summary
Annotation	Purpose														Used When
@Autowired	Injects a bean by type										Only one matching bean exists
@Qualifier	Resolves conflict when multiple beans of same type exist	Multiple beans are present


Q4. All components in spring boot

Ans:

‚úÖ 1. Core Spring Components (Inherited from Spring Framework)
Component					Description
@Component					Generic stereotype for any Spring-managed component
@Service					Marks a service class (business logic layer)
@Repository					Marks a DAO or repository class (database access layer)
@Controller					Handles web requests (used in Spring MVC)
@RestController				Combination of @Controller and @ResponseBody for REST APIs
@Autowired					Injects dependencies automatically
@Qualifier					Specifies which bean to inject when multiple candidates exist
@Configuration				Marks a class as a source of bean definitions
@Bean						Declares a bean in a @Configuration class
@Value						Injects values from application.properties or environment variables
@Scope						Defines the scope of a bean (singleton, prototype, etc.)
@PostConstruct, @PreDestroy	Lifecycle hooks

‚úÖ 2. Spring Boot Specific Components
Component									Description
@SpringBootApplication						Main annotation that combines @Configuration, @EnableAutoConfiguration, and @ComponentScan
@EnableAutoConfiguration					Enables Spring Boot‚Äôs auto configuration mechanism
@ComponentScan								Scans the package for Spring components
application.properties / application.yml	External configuration files
CommandLineRunner / ApplicationRunner		Run logic on application startup
SpringApplication.run()						Bootstraps the application
Actuator									Provides production-ready features like health checks, metrics, etc.
starter dependencies						Pre-configured dependencies (e.g., spring-boot-starter-web, spring-boot-starter-data-jpa)

‚úÖ 3. Web Development (Spring MVC)
Component									Description
@RequestMapping, @GetMapping, @PostMapping	Map HTTP requests to methods
@RequestBody								Binds request body to method parameter
@ResponseBody								Converts return value to response body
@PathVariable, @RequestParam				Extract data from URL/query params
@ExceptionHandler							Handle exceptions at controller level
Model, ModelAndView							Pass data to views (for JSP/Thymeleaf)

‚úÖ 4. Data Access (Spring Data / JPA)
Component						Description
@Entity							Marks a JPA entity (table)
@Id, @GeneratedValue			Marks primary key and auto-generation
@OneToMany, @ManyToOne, etc.	Define entity relationships
JpaRepository, CrudRepository	Built-in repository interfaces
@Query							Custom JPQL or native SQL queries
@Transactional					Manage transactions

‚úÖ 5. Security, Messaging, and Other Features
Feature		Common Components
Security	spring-boot-starter-security, @EnableWebSecurity, UserDetailsService, SecurityFilterChain
Messaging	@KafkaListener, @RabbitListener
Scheduling	@EnableScheduling, @Scheduled
Validation	@Valid, @NotNull, @Size, etc.
Testing		@SpringBootTest, @WebMvcTest, @DataJpaTest, JUnit, Mockito
Logging		Uses SLF4J + Logback by default
Profiles	@Profile, application-dev.properties, etc.

‚úÖ Optional Tools & Dev Features
Spring Boot DevTools ‚Äì auto reload and live reload

Spring Boot Actuator ‚Äì health, metrics, logging, env, etc.

Spring Boot CLI 	 ‚Äì command-line tool to run Groovy-based apps

Spring Initializr 	 ‚Äì to quickly scaffold Spring Boot projects


Q5. PUT vs PATCH

Ans.

üîÅ PUT vs PATCH
Feature					PUT											PATCH
Purpose					Replaces the entire resource				Partially updates the resource
Operation Type			Full update									Partial update
Idempotent				‚úÖ Yes (multiple calls have same effect)	‚úÖ Yes (but depends on implementation)
Payload					Contains complete resource data				Contains only the fields to be updated
Use Case				When you want to replace all fields			When you want to update specific fields

üîß Example
Assume this is the original resource:

{
  "id": 1,
  "name": "John",
  "email": "john@example.com"
}
‚úÖ PUT Request (Full Update)
PUT /users/1
Content-Type: application/json

{
  "id": 1,
  "name": "Johnny",
  "email": "johnny@example.com"
}
This replaces the entire object. Omitting a field (e.g., email) might delete or nullify it, depending on the backend.

‚úÖ PATCH Request (Partial Update)

PATCH /users/1
Content-Type: application/json

{
  "name": "Johnny"
}
This only updates the name field, and leaves email unchanged.

üîç Summary
Use PUT for complete replacement.

Use PATCH for minor or partial updates.